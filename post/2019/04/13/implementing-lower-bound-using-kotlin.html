<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<title>Kotlin으로 C++의 lower_bound, upper_bound 함수 구현하기 | KODINGWARRIOR QUEST</title>

<meta name="description" content="고생을 사서 하는 개발자의 여정은 앞으로도 계속됩니다." />
<link type="application/atom+xml" rel="alternate" href="/rss.xml" title="KODINGWARRIOR QUEST" />

<link rel="stylesheet" href="/_bridgetown/static/index.HM7I5HVM.css" />
<script src="/_bridgetown/static/index.FFIMB2ME.js" defer></script>


  </head>
  <body class="post ">
    
<nav>
  <ul>
    <li><a href="/">/home</a></li>
    <li><a href="/about">/about</a></li>
    <li><a href="/posts">/posts</a></li>
    <li><a href="/wiki">/wiki</a></li>
  </ul>
</nav>


    <main>
      <article>
        <script type="text/javascript" async>
    const url_default_fb = "https://www.facebook.com/sharer/sharer.php?u=";
    const url_default_tw_txt = "https://twitter.com/intent/tweet?text=";
    const url_default_tw_url = "&url=";
    const url_this_page = encodeURIComponent(location.href);
    const title_this_page = encodeURIComponent(document.title);
    const url_combine_fb = url_default_fb + url_this_page;
    const url_combine_tw = url_default_tw_txt + title_this_page + url_default_tw_url + url_this_page;
</script>

<h1>Kotlin으로 C++의 lower_bound, upper_bound 함수 구현하기</h1>

<div class="flex justify-end mb-6">
    <!-- Facebook share button -->
    <a href="" class="mx-4" title="페이스북으로 공유하기" onclick="window.open(url_combine_fb, '', 'scrollbars=no, width=600, height=600');">
        <i class="bi bi-facebook text-4xl"></i>
    </a>
    <!-- Twitter share button -->
    <a href="" title="트위터로 공유하기" onclick="window.open(url_combine_tw, '', 'scrollbars=no, width=600, height=600');">
        <i class="bi bi-twitter text-4xl"></i>
    </a>
</div>

<article>
    <blockquote>
  <p>TL;DR</p>
  <ul>
    <li>
      <p><strong><code class="highlighter-rouge">lower_bound</code></strong>, <strong><code class="highlighter-rouge">upper_bound</code></strong>를 구현할 때 반열린 구간 Notation을 지키는 것이 좋다.</p>
    </li>
    <li><strong><code class="highlighter-rouge">lower_bound</code></strong> 구현하기
      <ol>
        <li>이분탐색을 수행하듯이 lo, mid, hi 파라미터를 반복문 돌려가면서 적당히 조정한다.(<strong><code class="highlighter-rouge">while(lo &lt; hi)</code></strong>)</li>
        <li>mid가 가리키는 값이 <strong>value보다 작으면(<code class="highlighter-rouge">elements[mid] &lt; value</code>)</strong>, 탐색해야 하는 범위가 뒤쪽에 있다고 가정한다. → <strong><code class="highlighter-rouge">lo = mid + 1</code></strong></li>
        <li>mid가 가리키는 값이 <strong>value보다 크거나 같으면</strong>(<strong><code class="highlighter-rouge">elements[mid] ≥ value</code></strong>),  탐색해야 하는 범위는 좁혀진다.(<strong><code class="highlighter-rouge">high = mid</code></strong>)</li>
        <li>탐색에 성공하여 value 이상의 값이 처음 나타나는 위치를 발견하게 된다면, 탐색 범위가 좁혀진 <strong><code class="highlighter-rouge">lo</code></strong>(==<strong><code class="highlighter-rouge">hi</code></strong>)를 반환한다.</li>
        <li>탐색에 실패하여 mid가 포함되지 않는 구간인 high에 도달하게 된다면, 없다고 가정하고 high를 반환한다.</li>
      </ol>
    </li>
    <li><strong><code class="highlighter-rouge">upper_bound</code></strong> 구현하기
      <ol>
        <li>이분탐색을 수행하듯이 lo, mid, hi 파라미터를 반복문 돌려가면서 적당히 조정한다.(<strong><code class="highlighter-rouge">while(lo &lt; hi)</code></strong>)</li>
        <li>mid가 가리키는 값이 <strong>value보다 작거나 같으면(<code class="highlighter-rouge">elements[mid] &lt;= value</code></strong>), 탐색해야 하는 범위가 뒤쪽에 있다고 가정한다. → <strong><code class="highlighter-rouge">lo = mid + 1</code></strong></li>
        <li>mid가 가리키는 값이 <strong>value보다 크면</strong>(<strong><code class="highlighter-rouge">elements[mid] &gt; value</code></strong>), 탐색해야 하는 범위는 좁혀진다.(<strong><code class="highlighter-rouge">high = mid</code></strong>)</li>
        <li>탐색에 성공하여 value를 넘는 값이 처음 나타나는 위치를 발견하게 된다면, 탐색 범위가 좁혀진 <strong><code class="highlighter-rouge">lo</code></strong>(==<strong><code class="highlighter-rouge">hi</code></strong>)를 반환한다.</li>
        <li>mid가 포함되지 않는 구간인 high에 도달하게 된다면, 없다고 가정하고 high를 반환한다.</li>
      </ol>
    </li>
    <li><strong>Kotlin</strong> 믿고 잡숴보시라</li>
  </ul>
</blockquote>

<p>이 글에서는 <strong>Kotlin</strong>을 이용해서, <strong>C++</strong>의 STL에서 제공되는 <strong><code class="highlighter-rouge">lower_bound</code></strong>, <strong><code class="highlighter-rouge">upper_bound</code></strong> 함수를 어떻게 구현하게 되었는지 공유하고자 한다.</p>

<p>프로그래밍 대회 준비/학회 내부 알고리즘 교육 때문에 <strong>C++</strong>로 알고리즘 문제를 풀어왔었지만, 학부 생활을 벗어나니 <strong>C++</strong>를 쓸 일도 없어졌다. <strong>웹 개발자</strong>로서 주로 접하게 되는 언어는 <strong>Java</strong>, <strong>Python</strong>, <strong>Ruby</strong>, <strong>Javascript</strong> 정도 밖에 되지 않는다. 그 중에서도 <a href="https://acmicpc.net">Baekjoon Online Judge</a>에서 대부분의 알고리즘 문제를 풀 수 있으려면 가장 무난한 언어가 <strong>Java</strong>였다.</p>

<p><strong><code class="highlighter-rouge">Java로 알고리즘 문제 푸는 걸 연습해야겠다</code></strong>고 결심이 들던 와중 <a href="https://www.acmicpc.net/blog/view/71">이런 글</a>을 발견했다. <strong>Kotlin</strong>을 이용해서 알고리즘 문제를 푸는 방법을 기초적인 수준에서 설명하는 글이다. 뒤에서 설명하겠지만, <strong>Java</strong>로 알고리즘 문제를 푸는 행위에 회의감을 느끼던 나에게는 상당히 흥미롭게 느껴졌고, <a href="https://shiftpsh.com/">저자 분</a>에게 직접 이것저것 물어보면서 <strong>Kotlin</strong>으로 알고리즘 문제를 푸는 방법을 연마하는 중이다.</p>

<h2 id="kotlin으로-ps를-하면서-느낀-점">Kotlin으로 PS를 하면서 느낀 점</h2>

<p>대략 <strong>4월 초</strong>부터 <strong>Kotlin</strong>으로 알고리즘 문제를 풀기 시작했다. <strong>C++</strong>가 아닌 언어로 알고리즘 문제를 풀어놓은 흔적을 남겨놓은 <a href="https://github.com/malkoG/polyglot-cp">리포지토리</a>를 한달 전부터 유지하고 있는데, <code class="highlighter-rouge">.kt</code> 확장자가 보인다면 <strong><code class="highlighter-rouge">이게 Kotlin으로 풀이한거구나</code></strong>하고 이해하면 된다.</p>

<p><strong><code class="highlighter-rouge">Kotlin</code></strong>으로 알고리즘 문제를 풀게 된 건 그렇게 오래되지는 않았지만, 1주~2주의 짧은 기간 동안 건드리면서 느꼈던 점들을 간단하게 아래에서 정리했다.</p>

<h3 id="좋았던-점"><strong>좋았던 점</strong></h3>

<ul>
  <li><strong>Java</strong>와 100% 호환되기 때문에, <strong>Java</strong>에서 제공하는 클래스를 그대로 끌어다 쓸 수 있다. (컨테이너 클래스는 <strong>C++</strong> 못지 않다)</li>
  <li><strong>Java</strong>로 코딩하는 방식에 비해, 불편한 점이 상당히 줄었다.
    <ul>
      <li><strong><code class="highlighter-rouge">Pair</code></strong>, <strong><code class="highlighter-rouge">Triple</code></strong> 자료구조를 지원한다.  (<strong>Java</strong>에서는 이런 자료구조까지 클래스와 생성자로 직접 정의해야 했고, 정렬할 때도 정렬 함수를 따로 정의해줘야 하는 불편함이 있다. 하지만 코틀린에서는? 그런거 없다. 이미 만들어져 있고, 생성자도 잘 정의되어 있고, 정렬 함수도 납득할만한 수준으로 잘 정의되어 있다. <strong>C++</strong>에서 옮겨와도 크게 불편함이 없을 수준이다.)</li>
      <li>디폴트 파라미터를 지원한다.</li>
      <li>연산자 오버로딩을 지원한다. (<strong>Java</strong>에서는 <strong><code class="highlighter-rouge">ArrayList</code></strong> 컬렉션에 random access를 할 때, <code class="highlighter-rouge">.at(idx)</code> 노테이션을 이용해서 접근해야 하는 불편함이 있었지만, <strong>Kotlin</strong>에서는 random access를 할 때 <code class="highlighter-rouge">[idx]</code> 노테이션으로 접근하기만 하면 된다. <strong><code class="highlighter-rouge">String</code></strong>도 마찬가지로 적용된다.)</li>
      <li><strong><code class="highlighter-rouge">typealias</code></strong>를 지원한다. (<strong>Java</strong>는 상속으로 흉내내야 한다.)</li>
      <li>불필요한 OOP 문법을 적용하지 않아도 된다.(<strong>Kotlin</strong>으로 문제 풀면서 <strong><code class="highlighter-rouge">public static class</code></strong> 이런걸 거의 보지 않았던 것 같다.)</li>
    </ul>
  </li>
  <li><strong>C++</strong> 최신 표준 못지 않게 현대적인 문법이 많이 제공된다. (destructuring, 메서드 연쇄 중 어딘가에서 null이 튀어나오면 null을 리턴하는 등 Optional type에 대한 우아한 처리)</li>
</ul>

<h3 id="아쉬웠던-점"><strong>아쉬웠던 점</strong></h3>

<ul>
  <li><strong>C++</strong>에 비해 제공되는 함수가 적다. 정확히는, 필요한데 제공되지 않는 함수들이 있어서 빈자리가 느껴진다.(<strong><code class="highlighter-rouge">lower_bound/upper_bound</code></strong> 등 이분 탐색을 응용한 함수, <strong><code class="highlighter-rouge">next_permutation/prev_permutation</code></strong> 등 순열을 다루는 함수)</li>
  <li>컴파일 속도가 좀 느리다.</li>
  <li><strong>Java</strong>와 100% 호환이 되는 건 좋지만, 공식 문서가 모자란 것 같다는 느낌이 든다. (<strong>Java</strong> 공식 문서를 더 많이 봤던 것 같다.)</li>
</ul>

<h2 id="없으면-직접-만들어야지-뭐">없으면 직접 만들어야지, 뭐…</h2>

<p>알고리즘 문제 중에는 이분탐색으로 분류된 여러가지 문제가 있는데, 이분탐색으로 분류된 문제 중에는 <strong><code class="highlighter-rouge">lower_bound</code></strong>, <strong><code class="highlighter-rouge">upper_bound</code></strong> 함수를 이용해야만 편리하게 풀 수 있는 문제들이 있다. 하지만, 위에서 언급했다시피 <strong>Kotlin에서는 이런 함수를 가져다 쓸 수가 없다</strong>. 그러면 뭐다? 직접 만들어야지.</p>

<h3 id="lower_bound"><strong>lower_bound</strong></h3>

<blockquote>
  <p>C++에서 <strong><code class="highlighter-rouge">lower_bound</code></strong> 함수를 어떻게 활용하는지는 <a href="https://en.cppreference.com/w/cpp/algorithm/lower_bound">여기</a>에서 볼 수 있다.</p>
</blockquote>

<p><strong><code class="highlighter-rouge">lower_bound</code></strong>는 정렬된 리스트 내에서 특정 값 이상의 값이 처음 나타나는 위치를 반환하는 함수로 구현되어야 한다. 일단, 구현되는 원리는 이분탐색에서 기반한 거라고 주워들은 게 있었기 때문에, <strong>Parametric Search</strong>를 적용하던 방식을 떠올리기 시작했다.</p>

<p><strong>Parametric Search</strong>는 어떤 값이 정답일 지 알 수 없지만, <strong>결과값 y</strong>가 결정되어 있을 때 <strong><code class="highlighter-rouge">f(x) = y</code></strong> 식을 만족하도록 이분탐색으로 solution이 될 수 있는 범위를 좁혀가면서 solution x의 최솟값/최댓값을 구하는데 쓰이는 알고리즘이다. <strong>Parametric Search</strong>를 적용할 수 있으려면, 적용되는 함수가 <strong>단조증가함수</strong>이거나 <strong>단조감소함수</strong>여야 한다는 제약이 있다.</p>

<p>함수 <strong><code class="highlighter-rouge">f(x)</code></strong>가 <strong>단조증가함수</strong>라고 가정해보자. <strong>Parametric Search</strong>는 이런 조건에서 아래와 같이 구현할 수 있다.</p>

<blockquote>
  <p>i) <strong><code class="highlighter-rouge">f(x1) &lt; y</code></strong>일 경우, <strong><code class="highlighter-rouge">f(x)</code></strong>는 <strong>단조증가함수</strong>이기 때문에 <strong>해답이 되는 x는 x1보다 뒤에 있다</strong>고 생각할 수 있다.
ii) <strong><code class="highlighter-rouge">f(x1) &gt; y</code></strong>일 경우, <strong><code class="highlighter-rouge">f(x)</code></strong>는 <strong>단조증가함수</strong>이기 때문에 <strong>해답이 되는 x는 x1보다 앞에 있다</strong>고 생각할 수 있다.
iii) 특정구간에서 계단함수로 나타날 가능성이 있기 때문에, <strong><code class="highlighter-rouge">f(x1) = y</code></strong>일 때, 탐색범위가 하나로 좁혀질때까지 탐색범위를 줄여나간다.</p>
</blockquote>

<p><strong><code class="highlighter-rouge">lower_bound</code></strong>도 어떻게 보면 <strong>Parametric Search</strong>의 응용이라고 볼 수 있는데, 해의 범위는 조사를 시작하는 인덱스 low와 조사를 끝내는 인덱스 high 사이이며, 적용되는 함수는 인자로 넘겨진 배열 <strong><code class="highlighter-rouge">elements</code></strong>에 random access한 값이다. 이분탐색을 적용할 수 있으려면, <strong>“<code class="highlighter-rouge">elements</code>는 오름차순으로 정렬되어 있어야 한다”</strong>라는 전제조건이 있기 때문에, <strong>단조증가</strong>일 수 밖에 없다. 따라서, <strong><code class="highlighter-rouge">lower_bound</code></strong>도 <strong>Parametric Search</strong>처럼 구현이 가능하다.</p>

<p><strong>Parametric Search</strong>의 구현원리를 이용하여 <strong>Kotlin</strong>으로 <strong><code class="highlighter-rouge">lower_bound</code></strong> 함수를 구현한 코드는 아래와 같다.</p>
<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typealias</span> <span class="nc">Index</span> <span class="p">=</span> <span class="nc">Int</span>

<span class="k">fun</span> <span class="nf">lower_bound</span><span class="p">(</span><span class="n">elements</span><span class="p">:</span> <span class="nc">ArrayList</span><span class="p">&lt;</span><span class="nc">Int</span><span class="p">&gt;,</span>
		<span class="n">low</span><span class="p">:</span> <span class="nc">Index</span><span class="p">,</span> <span class="n">high</span><span class="p">:</span> <span class="nc">Index</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nc">Int</span><span class="p">)</span> <span class="p">:</span> <span class="nc">Index</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="py">lo</span> <span class="p">=</span> <span class="n">low</span>
	<span class="kd">var</span> <span class="py">hi</span> <span class="p">=</span> <span class="n">high</span>
	<span class="kd">var</span> <span class="py">mid</span><span class="p">:</span> <span class="nc">Index</span> <span class="p">=</span> <span class="n">high</span>
	<span class="k">while</span><span class="p">(</span><span class="n">lo</span> <span class="p">&lt;</span> <span class="n">hi</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mid</span> <span class="p">=</span> <span class="p">(</span><span class="n">lo</span> <span class="p">+</span> <span class="n">hi</span><span class="p">)</span> <span class="n">shr</span> <span class="mi">1</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mid</span> <span class="p">==</span> <span class="n">high</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">high</span>

		<span class="k">if</span><span class="p">(</span><span class="n">elements</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="p">&lt;</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// value보다 작은 값을 만난 경우</span>
			<span class="n">lo</span> <span class="p">=</span> <span class="n">mid</span> <span class="p">+</span> <span class="mi">1</span>            <span class="c1">// 탐색해야 하는 범위가 뒤쪽에 있다고 가정</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>                    <span class="c1">// value보다 크거나 같은 값을 만난 경우</span>
			<span class="n">hi</span> <span class="p">=</span> <span class="n">mid</span>                <span class="c1">// 탐색해야 하는 범위가 안쪽에 있다고 가정</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">lo</span>                     <span class="c1">// 맨 왼쪽 범위가 처음 나타나는 위치를 의미</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="upper_bound"><strong>upper_bound</strong></h3>

<blockquote>
  <p>C++에서 <strong><code class="highlighter-rouge">upper_bound</code></strong> 함수를 어떻게 활용하는지는 <a href="https://en.cppreference.com/w/cpp/algorithm/upper_bound">여기</a>에서 볼 수 있다.</p>
</blockquote>

<p><strong><code class="highlighter-rouge">upper_bound</code></strong>는 정렬된 리스트 내에서 특정 값을 넘는 값이 처음 나타나는 위치를 반환하는 함수로 구현되어야 한다. <strong><code class="highlighter-rouge">upper_bound</code></strong>는 <strong><code class="highlighter-rouge">lower_bound</code></strong>와 비슷하게 <strong><code class="highlighter-rouge">Parametric Search</code></strong>처럼 구현 가능하다.. 다만, 특정 원소보다 크거나 같은 값이 처음으로 나타나는 위치가 아닌 특정 원소보다 큰 값이 처음으로 나타나는 위치를 반환해야 하기 때문에, <strong><code class="highlighter-rouge">elements</code></strong>에 random access한 값이 찾고자 하는 값보다 작거나 같다면, 탐색해야 하는 범위는 뒤쪽에 있다고 가정해야 한다.</p>

<p><strong><code class="highlighter-rouge">Parametric Search</code></strong>의 구현원리를 이용하여 <strong><code class="highlighter-rouge">Kotlin</code></strong>으로 <strong><code class="highlighter-rouge">upper_bound</code></strong> 함수를 구현한 코드는 아래와 같다. <strong><code class="highlighter-rouge">lower_bound</code></strong>와 비슷하지만, 등호 부분만 바꿔주면 된다.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typealias</span> <span class="nc">Index</span> <span class="p">=</span> <span class="nc">Int</span>

<span class="k">fun</span> <span class="nf">upper_bound</span><span class="p">(</span><span class="n">elements</span><span class="p">:</span> <span class="nc">ArrayList</span><span class="p">&lt;</span><span class="nc">Int</span><span class="p">&gt;,</span>
		<span class="n">low</span><span class="p">:</span> <span class="nc">Index</span><span class="p">,</span> <span class="n">high</span><span class="p">:</span> <span class="nc">Index</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nc">Int</span><span class="p">)</span> <span class="p">:</span> <span class="nc">Index</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="py">lo</span> <span class="p">=</span> <span class="n">low</span>
	<span class="kd">var</span> <span class="py">hi</span> <span class="p">=</span> <span class="n">high</span>
	<span class="kd">var</span> <span class="py">mid</span><span class="p">:</span> <span class="nc">Index</span> <span class="p">=</span> <span class="n">high</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">lo</span> <span class="p">&lt;</span> <span class="n">hi</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mid</span> <span class="p">=</span> <span class="p">(</span><span class="n">lo</span> <span class="p">+</span> <span class="n">hi</span><span class="p">)</span> <span class="n">shr</span> <span class="mi">1</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mid</span> <span class="p">==</span> <span class="n">high</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">high</span>

		<span class="k">if</span><span class="p">(</span><span class="n">elements</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="p">&lt;=</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// value보다 작거나 같은 값을 만난 경우</span>
			<span class="n">lo</span> <span class="p">=</span> <span class="n">mid</span> <span class="p">+</span> <span class="mi">1</span>              <span class="c1">// 탐색 범위가 뒤쪽에 있다고 가정</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>                      <span class="c1">// value보다 큰 값을 만난 경우</span>
			<span class="n">hi</span> <span class="p">=</span> <span class="n">mid</span>                  <span class="c1">// 탐색 범위가 안쪽에 있다고 가정</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">lo</span>                       <span class="c1">// 맨 왼쪽 범위가 처음 나타나는 위치를 의미</span>
<span class="p">}</span>
</code></pre></div></div>
<h3 id="equal_range"><strong>equal_range</strong></h3>

<blockquote>
  <p>C++에서 <strong><code class="highlighter-rouge">equal_range</code></strong> 함수를 어떻게 활용하는지는 <a href="https://en.cppreference.com/w/cpp/algorithm/equal_range">여기</a>에서 볼 수 있다.</p>
</blockquote>

<p><strong><code class="highlighter-rouge">equal_range</code></strong>는 정렬된 리스트 내에서 특정 값이 나타나는 구간을 반열린 구간으로 반환하는 함수로 구현되어야 한다. <strong><code class="highlighter-rouge">equal_range</code></strong>를 구현하는 건 그렇게 어렵지 않다. <strong><code class="highlighter-rouge">lower_bound</code></strong>, <strong><code class="highlighter-rouge">upper_bound</code></strong>로 구성된 <strong><code class="highlighter-rouge">Pair</code></strong>를 반환하면 그만이다.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typealias</span> <span class="nc">Index</span> <span class="p">=</span> <span class="nc">Int</span>

<span class="c1">// equal_range는 정렬된 리스트의 [low, high) 구간 사이에서 특정 값이 나타나는 구간을 Pair로 반환한다.</span>
<span class="c1">// lower_bound == upper_bound일 경우, value가 나타나는 구간은 없다고 가정한다.</span>
<span class="c1">// low : 조사를 시작하는 구간(닫힌 구간) - 포함</span>
<span class="c1">// high : 조사를 끝내는 구간(열린 구간) - 미포함</span>
<span class="c1">// value : 조사할 값</span>
<span class="k">fun</span> <span class="nf">equal_range</span><span class="p">(</span><span class="n">elements</span><span class="p">:</span> <span class="nc">ArrayList</span><span class="p">&lt;</span><span class="nc">Int</span><span class="p">&gt;,</span>
		<span class="n">low</span><span class="p">:</span> <span class="nc">Index</span><span class="p">,</span> <span class="n">high</span><span class="p">:</span> <span class="nc">Index</span><span class="p">,</span>  <span class="n">value</span><span class="p">:</span> <span class="nc">Int</span><span class="p">)</span> <span class="p">:</span> <span class="nc">Pair</span><span class="p">&lt;</span><span class="nc">Index</span><span class="p">,</span><span class="nc">Index</span><span class="p">&gt;</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nc">Pair</span><span class="p">(</span><span class="nf">lower_bound</span><span class="p">(</span><span class="n">elements</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">value</span><span class="p">),</span> <span class="nf">upper_bound</span><span class="p">(</span><span class="n">elements</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">val</span> <span class="p">(</span><span class="py">lower</span><span class="p">,</span><span class="py">upper</span><span class="p">)</span> <span class="p">=</span> <span class="nf">equal_range</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nc">N</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span> 
</code></pre></div></div>

<h2 id="마치며">마치며</h2>

<p><strong>Kotlin</strong>을 개발한 JetBrain에서 ACM-ICPC(세계 대학생 프로그래밍 대회)를 후원하고 있다. <a href="https://blog.jetbrains.com/kr/2017/06/jetbrains-acm-icpc-%EA%B3%B5%EC%8B%9D-%ED%9B%84%EC%9B%90/">ACM-ICPC 공식 페이지에서도 Kotlin을 지원하게 될 것</a>이라고 밝혔기 때문에, <strong><code class="highlighter-rouge">Kotlin을 이용한 알고리즘 문제 풀이</code></strong>에 대한 수요는 계속해서 증가할 것이라 본다.</p>

<p>하지만, 아직까지는 국내에 <strong>Kotlin</strong>을 이용해서 알고리즘 문제를 풀이하는 방법을 소개하는 리소스가 많지 않다. <strong>Kotlin</strong>이라는 언어가 아직까지는 <strong><code class="highlighter-rouge">Java에 대한 배경지식을 요구한다는 인식</code></strong>이 지배적이며, <strong>Kotlin</strong>이 정규 교과과정에 들어가는 언어도 아니다보니 따로 공부하는 사람만 알고 있는 편이다.</p>

<p>국내에서 출판된 <strong>Kotlin</strong> 도서도 <strong>Java</strong>에 대한 배경지식이 있다고 가정하고 쓰여진 책이 여럿 있다보니, <strong><code class="highlighter-rouge">"Kotlin을 하려면 Java를 알아야 한다"</code></strong>가 통념이 되어버리는 것 같다. <strong><code class="highlighter-rouge">C++를 알기 위해서, C를 알고 있어야 한다</code></strong>는 논리처럼 보여지기도 하지만, 나도 역시 <strong>Java</strong>를 어느 정도 공부하고 나서 <strong>Kotlin</strong>을 영접한 케이스이고, 개인차가 있는 것 같으니 확실히 답하기는 어렵다.</p>

<p>그럼에도, <strong>Kotlin</strong>은 정말 배우기 쉬운 편이며, 문법이 다른 언어 못지 않게 간결하며, 배울만한 가치가 있다. 지금 당장은 암흑기라고 판단되지만, 조만간 대중적인 언어로서 주가가 크게 상승할 것이라고 강하게 촉이 오는 언어는 <strong>Kotlin</strong>이 처음이었다. 대중적으로 쓰이는 <strong>Java</strong>와 100% 호환이 되며, <strong>Java</strong>와 비슷하면서도 <strong>Java</strong>보다 문법이 훨씬 간결하고 편의 문법이 여럿 제공되는데 <strong>Kotlin</strong>을 선택하지 않을 이유가 무엇이란 말인가?</p>

<p><strong>Kotlin</strong>, 한번 믿고 잡숴보시라.</p>

</article>

<!-- buy me a coffee -->
<style>.bmc-button img{width: 27px !important;margin-bottom: 1px !important;box-shadow: none !important;border: none !important;vertical-align: middle !important;}.bmc-button{line-height: 36px !important;height:37px !important;text-decoration: none !important;display:inline-flex !important;color:#ffffff !important;background-color:#BB5794 !important;border-radius: 3px !important;border: 1px solid transparent !important;padding: 1px 9px !important;font-size: 22px !important;letter-spacing:0.6px !important;box-shadow: 0px 1px 2px rgba(190, 190, 190, 0.5) !important;-webkit-box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;margin: 0 auto !important;font-family:'Cookie', cursive !important;-webkit-box-sizing: border-box !important;box-sizing: border-box !important;-o-transition: 0.3s all linear !important;-webkit-transition: 0.3s all linear !important;-moz-transition: 0.3s all linear !important;-ms-transition: 0.3s all linear !important;transition: 0.3s all linear !important;}.bmc-button:hover, .bmc-button:active, .bmc-button:focus {-webkit-box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;text-decoration: none !important;box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;opacity: 0.85 !important;color:#ffffff !important;}</style><link href="https://fonts.googleapis.com/css?family=Cookie" rel="stylesheet">

<div class="text-center my-4">
    <a class="bmc-button" target="_blank" href="https://qr.kakaopay.com/Ej8T6e8CM5dc06009"><img src="https://www.buymeacoffee.com/assets/img/BMC-btn-logo.svg" alt="Buy me a coffee"><span style="margin-left:5px">Buy me a coffee</span></a>
</div>
<script src="https://utteranc.es/client.js"
    repo="kodingwarrior/kodingwarrior.github.io"
    issue-term="title"
    theme="github-light"
    crossorigin="anonymous"
    async>
</script>
      </article>
    </main>

    <footer class="flex justify-start sm:justify-center flex-col sm:flex-row">
  <a class="my-2 mx-3 no-underline" href="/rss.xml">
    <i class="bi bi-rss-fill text-2xl"></i> Feed
  </a>
  <a class="my-2 mx-3 no-underline" href="mailto:rijgndqw012@gmail.com">
    <i class="bi bi-envelope-fill text-2xl"></i> Email
  </a>
  <a class="my-2 mx-3 no-underline" href="https://twitter.com/kodingwarrior">
    <i class="bi bi-twitter text-2xl"></i> Twitter
  </a>
  <a class="my-2 mx-3 no-underline" href="https://github.com/kodingwarrior/kodingwarrior.github.io">
    <i class="bi bi-github text-2xl"></i> Github
  </a>
</footer>


    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-127979309-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-127979309-1');
    </script>
  </body>
</html>
