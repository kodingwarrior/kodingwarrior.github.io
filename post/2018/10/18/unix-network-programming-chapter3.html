<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<title>Unix Network Programming Chapter 3 : Socket Introduction | KODINGWARRIOR QUEST</title>

<meta name="description" content="고생을 사서 하는 개발자의 여정은 앞으로도 계속됩니다." />
<link type="application/atom+xml" rel="alternate" href="/rss.xml" title="KODINGWARRIOR QUEST" />

<link rel="stylesheet" href="/_bridgetown/static/index.QHO7TC5T.css" />
<script src="/_bridgetown/static/index.FFIMB2ME.js" defer></script>


  </head>
  <body class="post ">
    
<nav>
  <ul>
    <li><a href="/">/home</a></li>
    <li><a href="/about">/about</a></li>
    <li><a href="/posts">/posts</a></li>
    <li><a href="/wiki">/wiki</a></li>
  </ul>
</nav>


    <main>
      <article>
        <script type="text/javascript" async>
    const url_default_fb = "https://www.facebook.com/sharer/sharer.php?u=";
    const url_default_tw_txt = "https://twitter.com/intent/tweet?text=";
    const url_default_tw_url = "&url=";
    const url_this_page = encodeURIComponent(location.href);
    const title_this_page = encodeURIComponent(document.title);
    const url_combine_fb = url_default_fb + url_this_page;
    const url_combine_tw = url_default_tw_txt + title_this_page + url_default_tw_url + url_this_page;
</script>

<h1>Unix Network Programming Chapter 3 : Socket Introduction</h1>

<div class="flex justify-end mb-6">
    <!-- Facebook share button -->
    <a href="" class="mx-4" title="페이스북으로 공유하기" onclick="window.open(url_combine_fb, '', 'scrollbars=no, width=600, height=600');">
        <i class="bi bi-facebook text-4xl"></i>
    </a>
    <!-- Twitter share button -->
    <a href="" title="트위터로 공유하기" onclick="window.open(url_combine_tw, '', 'scrollbars=no, width=600, height=600');">
        <i class="bi bi-twitter text-4xl"></i>
    </a>
</div>

<article>
    <h1 id="31-introduction">3.1 Introduction</h1>

<p>이 챕터에서는 전반적으로 네트워크 프로그래밍에서 주로 활용되는 socket API 를 다룰때 알아둬야 할 내용을 다루고 있다. 소켓 주소 구조체를 다루는 자료구조를 다루는 것부터 시작해서, 1) 프로세스에서 커널로, 2) 커널에서 프로세스로 어떻게 소켓 주소 구조체를 통해 정보를 전달하는지를 다루며,  IP 주소를 나타내는 텍스트 표현법과 소켓 주소 구조체에 저장되는 이진 값 사이의 변환을 해주는 <code class="highlighter-rouge">inet_addr</code>, <code class="highlighter-rouge">inet_ntoa</code> 함수를 다루면서도 IPv4/IPv6 의 호환을 위해 <code class="highlighter-rouge">inet_pton</code>, <code class="highlighter-rouge">inet_ntop</code> 유틸리티 함수를 다룬다.</p>

<h1 id="32-socket-address-structure">3.2 Socket Address Structure</h1>
<p>IPv4 소켓 주소 구조체는 흔히 <code class="highlighter-rouge">인터넷 소켓 주소 구조체</code> 라고 불리며, <code class="highlighter-rouge">&lt;netinet/in.h&gt;</code> 헤더 파일에 <code class="highlighter-rouge">sockaddr_in</code> 이라는 구조체로서 정의되어 있다.</p>

<p>POSIX 표준에서는 아래와 같이 정의되어 있다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">in_addr</span> <span class="p">{</span>
    <span class="n">in_addr_t</span> <span class="n">s_addr</span><span class="p">;</span> <span class="cm">/* 32 bit IPv4 주소이며, 네트워크 바이트 순서 */</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="p">{</span>
    <span class="kt">uint8_t</span>  <span class="n">sin_len</span><span class="p">;</span> <span class="cm">/* 구조체의 크기 */</span>
    <span class="n">sa_family_t</span> <span class="n">sin_family</span><span class="p">;</span> <span class="cm">/* AF_INET */</span>
    <span class="n">in_port_t</span> <span class="n">sin_port</span><span class="p">;</span> <span class="cm">/* 포트 번호를 담기 위한 16 bit 변수이며, 네트워크 바이트 순서 */</span>
		
    <span class="k">struct</span> <span class="n">in_addr</span> <span class="n">sin_addr</span><span class="p">;</span> <span class="cm">/* 32 bit IPv4 주소이며, 네트워크 바이트 순서 */</span>
		
    <span class="kt">char</span> <span class="n">sin_zero</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span> <span class="cm">/* 사용되지 않는 패딩 바이트 */</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이를 시각화하면 아래와 같이 나타낼 수 있다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>+--------------+-----------------+---------------+-----------------------+
| sin_len : 1B | sin_family : 1B | sin_port : 2B | sin_addr(s_addr) : 4B |
+--------------+-----------------+---------------+-----------------------+
|                             sin_zero[] : 8B                            |
+------------------------------------------------------------------------+
</code></pre></div></div>

<p>여기서 좀 더 설명이 필요한 부분이 있는데,</p>

<ul>
  <li><code class="highlighter-rouge">sin_len</code>는 <strong>소켓 주소 구조체 자체의 크기</strong>를 나타내는 1 바이트 크기의 멤버변수이다. 운영체제에 따라, <code class="highlighter-rouge">sin_len</code> 멤버변수가 정의되어 있지 않기도 하는데, 그럴 경우에는 <code class="highlighter-rouge">sin_family</code> 가 첫번째로 나타나는 멤버변수이며 2 바이트의 크기를 가진다.</li>
  <li><code class="highlighter-rouge">s_addr</code>, <code class="highlighter-rouge">sin_family</code>, <code class="highlighter-rouge">sin_port</code> 멤버변수를 보면 <code class="highlighter-rouge">in_addr_t</code>, <code class="highlighter-rouge">in_port_t</code> 와 같이 사용자 정의 타입으로 정의되어 있는데, 어떤 시스템에서 이용하더라도 <code class="highlighter-rouge">in_port_t</code> 변수는 2byte, <code class="highlighter-rouge">sin_addr</code> 변수는 4byte 의 크기를 가지는 것을 보장해준다. 비슷한 예시로, <code class="highlighter-rouge">&lt;sys/types.h&gt;</code> 에는 <code class="highlighter-rouge">uint32_t</code>,  <code class="highlighter-rouge">uint8_t</code> 와 같이 어떤 아키텍쳐를 이용하더라도 항상 변수가 4바이트, 1바이트의 크기를 가지는 것을 보장해주는 자료형이 정의되어 있다.</li>
  <li>IPv4 주소와 TCP, UDP 포트 번호는 네트워크 바이트 순서로 저장된다. 네트워크 바이트 순서는 빅 엔디언 방식이며, 이는 3.4 절에서 상세한 정보를 알 수 있다.</li>
</ul>

<h2 id="generic-socket-address-structure">Generic Socket Address Structure</h2>

<p>소켓 주소 구조체는 <strong>항상</strong> 소켓과 관련된 함수의 인자에 주소값으로서 전달이 된다.</p>

<p>예를 들면, <code class="highlighter-rouge">bind</code> 함수를 보더라도 <code class="highlighter-rouge">int bind(int, struct sockaddr*, socklen_t);</code> 이와 같이 정의되어 있고, 함수에 인자를 넘겨줄 때는 <code class="highlighter-rouge">bind(sockfd, (struct sockaddr*) &amp;servaddr, sizeof(servaddr))</code> 와 같이 넘겨주게 된다. 여기서 <code class="highlighter-rouge">struct sockaddr</code> 구조체를 들여다볼 필요가 있는데, 이는 <code class="highlighter-rouge">&lt;sys/socket.h&gt;</code> 헤더파일에 아래와 같이 정의되어 있다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">sockaddr</span> <span class="p">{</span>
    <span class="kt">uint8_t</span> <span class="n">sa_len</span><span class="p">;</span>
    <span class="n">sa_family_t</span> <span class="n">sa_family</span><span class="p">;</span> <span class="cm">/* Address family : AF_XXX */</span>
    <span class="kt">char</span>  <span class="n">sa_data</span><span class="p">[</span><span class="mi">14</span><span class="p">];</span> <span class="cm">/* protocol-specific address */</span>
<span class="p">};</span>
</code></pre></div></div>

<p>위의 접근방법과 같이 포인터로 형변환을 하는 방식은 ANSI C 에서 <code class="highlighter-rouge">void *</code> 이라는 generic 포인터 타입으로 형변환하는 방식과 같다. generic한 접근에 <code class="highlighter-rouge">void *</code>를 사용하듯 <code class="highlighter-rouge">struct sockaddr</code>는 protocol에 특화된 소켓 주소 구조체를 좀 더 generic한 구조체의 포인터로 캐스팅하는 목적으로 쓰인다고 볼 수 있다.</p>

<h1 id="33-value-result-arguments">3.3 Value-Result Arguments</h1>

<p>value-result 전달 방식은 함수 내부에서 parameter에 대한 조작을 수행한 후, 함수가 리턴할 때 argument에 parameter에 대한 조작을 수행한 결과가 저장되는 방식을 나타낸다.</p>

<p>소켓 주소 구조체의 크기에 대한 변수가 어떻게 전달되는지는 1) 프로세스에서 커널로, 2) 커널에서 프로세스로 어느 방향으로 구조체가 전달되느냐에 따라 결정이 된다.</p>

<p>1) <code class="highlighter-rouge">bind</code>, <code class="highlighter-rouge">connect</code>, <code class="highlighter-rouge">send</code> 와 같은 함수는 소켓 주소 구조체를 프로세스에서 커널로 인자를 전달한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">serv</span><span class="p">;</span>

<span class="cm">/* fill in serv() */</span>
<span class="n">connect</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="p">(</span><span class="n">SA</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">serv</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">serv</span><span class="p">));</span>
</code></pre></div></div>
<p>2) 반면, <code class="highlighter-rouge">accept</code>, <code class="highlighter-rouge">recvfrom</code>, <code class="highlighter-rouge">getsockname</code>, <code class="highlighter-rouge">getpeername</code> 과 같은 함수는 소켓 주소 구조체를 커널에서 프로세스로 전달받는다. <code class="highlighter-rouge">accept</code> 의 예시를 들자면, 클라이언트의 연결을 기다리다가 클라이언트와 연결이 되었는데, 이 때 연결된 클라이언트가 어떤 주소를 가지고 있는지 정보를 나타내는 소켓 주소 구조체를 커널에서 프로세스로 전달받아야하고, 그 구조체의 크기가 얼마나 되는지에 대한 정보를 받아야 하는데,  프로세스의 <strong>어느 변수에다가 할당되면 좋겠는지 주소값을 함수의 인자로 넘기는 것</strong>이다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span>  <span class="n">sockaddr_un</span> <span class="n">cli</span><span class="p">;</span> <span class="cm">/* unix domain */</span>
<span class="n">socklen_t</span> <span class="n">len</span><span class="p">;</span>

<span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cli</span><span class="p">);</span>
<span class="n">getpeername</span><span class="p">(</span><span class="n">unixfd</span><span class="p">,</span> <span class="p">(</span><span class="n">SA</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">cli</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>
<span class="cm">/* len may have changed */</span>
</code></pre></div></div>

<p>네트워크 프로그래밍에서는 value-result 전달 방식으로 소켓 주소 구조체의 크기를 구하는 일이 흔히 있는 일이며, <code class="highlighter-rouge">select</code>, <code class="highlighter-rouge">getsockopt</code>, <code class="highlighter-rouge">sysctl</code> 함수 등을 다루면서 value-result 전달 방식을 계속 접하게 될 것이다.</p>
<h1 id="34-byte-ordering-functions">3.4 Byte Ordering Functions</h1>

<p>여러개의 바이트로 구성된 데이터가 메모리에 저장되는 순서는 크게 두 가지로 나뉘어진다.</p>

<ul>
  <li><code class="highlighter-rouge">리틀 엔디안</code> : LSB가 낮은 메모리 주소에 위치하고, MSB 가 높은 메모리 주소에 위치</li>
  <li><code class="highlighter-rouge">빅 엔디안</code> : MSB가 높은 메모리 주소에 위치하고, LSB가 낮은 메모리 주소에 위치</li>
</ul>

<p>메모리 상에서 바이트가 어떻게 정렬되는지는 CPU 제조업체에 따라 다르며, 현재 사용중인 컴퓨터에서 어떤 바이트 순서로 바이트가 정렬되는지는 터미널에서 <code class="highlighter-rouge">byteorder</code> 명령으로 확인할 수 있다.</p>

<p>네트워킹 프로토콜에서는 네트워크 바이트 순서로 데이터를 저장해서 쓰기 때문에, 네트워크 프로그래밍을 하려면 바이트 순서를 반드시 고려해야 한다.</p>

<p>호스트 바이트 순서에서 네트워크 바이트 순서로, 네트워크 바이트 순서에서 호스트 바이트 순서로 재정렬을 일일이 하기에는 너무 고통스러울 수 있기 때문에, <code class="highlighter-rouge">&lt;netinet/in.h&gt;</code> 헤더파일에 정의되어 있는 다음의 함수들을 이용하는게 훨씬 편리하다.</p>

<ul>
  <li><code class="highlighter-rouge">uint16_t htons(uint16_t)</code>, <code class="highlighter-rouge">uint32_t htonl(uint32_t)</code> : 네트워크 바이트 순서로 정렬된 값을 반환한다. host byte order to network byte order를 의미.</li>
  <li><code class="highlighter-rouge">uint16_t ntohs(uint16_t)</code>, <code class="highlighter-rouge">uint32_t ntohl(uint32_t)</code> : 호스트 바이트 순서로 정렬된 값을 반환한다. network byte order to host byte order를 의미.</li>
</ul>

<h1 id="35-byte-manipulation-functions">3.5 Byte Manipulation Functions</h1>
<p>데이터를 읽어들일 필요없이(각 멤버 변수에 대한 할당을 의미), 멀티바이트 필드를 조작할 수 있는 유틸리티 함수를 알아두는 게 좋다.</p>

<p>첫번째로는, b로 시작하는 함수인데 ANSI C 표준의 <code class="highlighter-rouge">&lt;string.h&gt;</code> 헤더파일의 <code class="highlighter-rouge">bzero</code>, <code class="highlighter-rouge">bcopy</code>, <code class="highlighter-rouge">bcmp</code> 함수가 꽤 쓸만하다. 비록 문자열을 다루는게 아니지만, 소켓 주소 구조체를 byte string 이라는 관점에서 본다면, 소켓 주소 구조체를 다루기 위해 바이트 단위로 접근할 수 있는 유용한 함수들이기도 하다.</p>
<ul>
  <li><code class="highlighter-rouge">void bzero(void* dest, size_t nbytes)</code> : 인자로 주어진 구조체를 n bytes 만큼 0으로 채운다.</li>
  <li><code class="highlighter-rouge">void bcopy(const void *src, void *dest, size_t nbytes)</code> : n bytes 만큼 src 에서 dest 로 값을 복사한다.</li>
  <li><code class="highlighter-rouge">int bcmp(const void *ptr1, const void *ptr2, size_t nbytes)</code> : 두 포인터가 가리키는 값이 n bytes 만큼 비교해서 동일하다면 0 를 반환한다. 동일하지 않다면 0이 아닌 값을 반환한다.</li>
</ul>

<p>두번째로는, mem 으로 시작하는 함수가 있는데, 위와 차이가 있긴 하지만 거의 동일하다.</p>
<ul>
  <li><code class="highlighter-rouge">void* memset(void *dest, int c, size_t len)</code> : <code class="highlighter-rouge">bzero</code> 와 동일하지만, 바이트 단위로 어떤 값으로 초기화할 것이냐의 차이가 있다. 0 으로 초기화할 수도 있고, -1로 초기화할 수도 있다.</li>
  <li><code class="highlighter-rouge">void* memcpy(void *dest, const void *src, size_t nbytes)</code> : <code class="highlighter-rouge">bcopy</code> 와 인자 전달 순서가 다르다.</li>
  <li><code class="highlighter-rouge">int memcmp(const void *ptr1, const void *ptr2, size_t nbytes)</code> : byte string 을 비교했을 때, 두 string 이 동일하다면 0, ptr1이 ptr2보다 크거나 작다면 음수 혹은 양수를 반환한다.</li>
</ul>

<h1 id="36-inet_aton-inet_addr-and-inet_ntoa-functions">3.6 <code class="highlighter-rouge">inet_aton</code>, <code class="highlighter-rouge">inet_addr</code>, and <code class="highlighter-rouge">inet_ntoa</code> Functions</h1>

<p>IPv4 주소를 표현하는 방법으로는 사람이 읽어들일 수 있는 ASCII 문자열로 표현하는 방법과, 네트워크 바이트 순서의 32비트 정수로 나타내는 방법이 있다. 각 표현방법을 다른 표현방법으로 변환시킬 수 있는 유틸리티 함수가 있으며, 이는 <code class="highlighter-rouge">&lt;arpa/inet.h&gt;</code> 헤더파일에 정의되어 있다.</p>

<ul>
  <li><code class="highlighter-rouge">int inet_aton(const char *strptr, struct in_addr *addrptr);</code> : ASCII 문자열로 나타낸 주소를 네트워크 바이트 순서의 32비트 정수로 변환하여 addrptr 포인터가 가리키는 값에 저장한다. 문자열이 올바르면 1, 오류가 발생하면 0를 반환한다.</li>
  <li><code class="highlighter-rouge">in_addr_t inet_addr(const char *strptr);</code> : <code class="highlighter-rouge">inet_aton</code>과 거의 같지만, deprecated 되었다.</li>
  <li><code class="highlighter-rouge">char *inet_ntoa(struct in_addr inaddr);</code> : 네트워크 바이트 순서의 32비트 정수로 나타낸 주소를 dotted-decimal(십진법으로 나타낸 주소) 문자열로 변환후, 문자열에 대한 포인터를 반환한다. 이 때, 문자열은 static memory 에 저장되어 있으며, 이 함수는 <code class="highlighter-rouge">reentrant</code> 하지 않다. 함수의 인자에 구조체에 대한 포인터가 아닌 구조체를 넘겨준다는 점을 주목하자.</li>
</ul>

<h1 id="37-inet_pton-and-inet_ntop-functions">3.7 <code class="highlighter-rouge">inet_pton</code> and <code class="highlighter-rouge">inet_ntop</code> Functions</h1>
<p><code class="highlighter-rouge">inet_pton</code> 과 <code class="highlighter-rouge">inet_ntop</code> 은 3.6절에서 설명한 <code class="highlighter-rouge">inet_aton</code>, <code class="highlighter-rouge">inet_ntoa</code> 함수처럼 동작하지만, IPv4 주소 뿐만 아니라 IPv6 주소에 대해서도 적용할 수 있는 버전이라 볼 수 있다. 이도 역시 <code class="highlighter-rouge">&lt;arpa/inet.h&gt;</code> 헤더파일에 정의되어 있다.</p>

<ul>
  <li><code class="highlighter-rouge">int inet_pton(int family, const char *strptr, void *addrptr)</code> : 문자열로 나타낸 IP 주소(strptr)를 네트워크 바이트 순서의 비트스트링으로 변환 후 포인터(addrptr)로 가리킨 변수에 저장한다. 성공하면 1을 반환하고, 유효하지 않은 주소표기법일 경우 0, 오류가 발생하면 -1을 반환한다.</li>
  <li><code class="highlighter-rouge">const char *inet_ntop(int family, const void *addrptr, char *strptr, size_t len)</code> : 위의 함수와 반대방향의 변환을 수행하는 함수이며, 변환에 성공하면 결과에 대한 포인터를 반환하고, 성공하지 못하면 NULL 포인터를 반환한다.
    <ul>
      <li><code class="highlighter-rouge">len</code> 변수는 목적지가 되는 strptr 의 길이를 의미하며, caller의 버퍼를 오버플로우 하지 않도록 방지하기 위한 목적으로 쓰인다. <code class="highlighter-rouge">len</code> 변수를 어떻게 넘겨줄지는 <code class="highlighter-rouge">&lt;netinet/in.h&gt;</code> 헤더파일에 관련된 상수가 정의되어 있다. <code class="highlighter-rouge">len</code> 변수가 비트스트링으로 주어진 네트워크 주소를 ASCII 문자열로 변환하기에 너무 적은 수일 경우 NULL 포인터를 반환하며, <code class="highlighter-rouge">errno</code> 변수에는 <code class="highlighter-rouge">ENOSPC</code> 라는 상수가 세팅된다.</li>
      <li>여기서 <code class="highlighter-rouge">strptr</code> 포인터에는 널포인터가 들어가면 안된다. 비트스트링으로 나타낸 네트워크 주소를 문자열로 나타낸 결과가 strptr 가 가리키는 값에 세팅되어야 하기 때문에, 위의 함수를 호출하기 전에 목적지의 주소에 적당한 크기의 메모리를 할당해야한다. 위의 함수에서 변환이 성공하면, <code class="highlighter-rouge">strptr</code> 주소가 반환된다.</li>
    </ul>
  </li>
</ul>

<p>위의 두 함수에서 <code class="highlighter-rouge">family</code> 인자에는 AF_INET, AF_INET6가 들어갈 수 있으며,  <code class="highlighter-rouge">family</code>가 지원되지 않을 경우, <code class="highlighter-rouge">errno</code> 변수에 <code class="highlighter-rouge">EAFNOSUPPORT</code> 라는 상수를 세팅하고, 오류를 반환한다.</p>

<p><code class="highlighter-rouge">inet_pton</code> 함수와 <code class="highlighter-rouge">inet_ntop</code> 함수를 IPv4 주소만 지원하도록 직접 구현한다면 아래와 같이 구현할 수 있을 것이다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span>
<span class="nf">inet_pton</span><span class="p">(</span><span class="kt">int</span> <span class="n">family</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">strptr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addrptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span><span class="p">(</span><span class="n">family</span> <span class="o">==</span> <span class="n">AF_INET</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">in_addr</span> <span class="n">in_val</span><span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">inet_aton</span><span class="p">(</span><span class="n">strptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">in_val</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">addrptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">in_val</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">in_addr</span><span class="p">));</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>  
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">errno</span> <span class="o">=</span> <span class="n">EAFNOSUPPORT</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span>
<span class="nf">inet_ntop</span><span class="p">(</span><span class="kt">int</span> <span class="n">family</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addrptr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">strptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">u_char</span> <span class="o">*</span><span class="p">)</span> <span class="n">addrptr</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">family</span> <span class="o">==</span> <span class="n">AF_INET</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="n">temp</span><span class="p">[</span><span class="n">INET_ADDRSTRLEN</span><span class="p">];</span>

		<span class="n">snprintf</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tmp</span><span class="p">),</span> <span class="s">"%d.%d.%d.%d"</span><span class="p">,</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
		<span class="k">if</span><span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">errno</span> <span class="o">=</span> <span class="n">ENOSPC</span><span class="p">;</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">strcpy</span><span class="p">(</span><span class="n">strptr</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">strptr</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">errno</span> <span class="o">=</span> <span class="n">EAFNOSUPPORT</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="39-readn-writen-and-readline-functions">3.9 <code class="highlighter-rouge">readn</code>, <code class="highlighter-rouge">writen</code> and <code class="highlighter-rouge">readline</code> Functions</h1>

<p>일반적인 파일 IO와는 달리 TCP 소켓과 같은 스트림 소켓에 <code class="highlighter-rouge">read</code> 시스템콜이나 <code class="highlighter-rouge">write</code> 시스템콜을 이용하여 IO를 수행하는것은 왠만하면 금지되어 있다. 커널에서 소켓에 대해 입출력을 수행할때, 버퍼의 크기가 제한되어 있기 때문이다. <code class="highlighter-rouge">read</code> 시스템콜, <code class="highlighter-rouge">write</code> 시스템콜을 이용하여 IO를 수행했을때, 이만큼 IO를 해달라고 커널에 요청한 수에 비해 실제로 IO를 수행한 바이트의 수(이는 <code class="highlighter-rouge">read</code>, <code class="highlighter-rouge">write</code> 함수의 결과로 반환된다.) 가 적을 수 있으며, 이는 에러를 의미하는 것이 아니다. 따라서, IO를 완전하게 끝내기 위해서, IO를 수행하다가 남은 나머지 부분을 처리할때까지 다시 <code class="highlighter-rouge">read</code>, <code class="highlighter-rouge">write</code> 를 수행하도록 해야할 것이다.</p>

<p>실제로 유닉스 일부 버전에서는 4096 바이트가 넘도록 파이프를 통해 write 를 수행하는 행위를 금지하고 있다.</p>

<p>socket 에 대해서도 <code class="highlighter-rouge">read</code>, <code class="highlighter-rouge">write</code> 를 수행할 수 있도록 하기 위해, 책에서는 아래와 같이 유틸리티 함수<code class="highlighter-rouge">readn</code>, <code class="highlighter-rouge">writen</code>, <code class="highlighter-rouge">readline</code> 를 정의하고 있다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">ssize_t</span>
<span class="nf">readn</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">vptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span> 
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">nleft</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">nread</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
	
	<span class="n">ptr</span> <span class="o">=</span> <span class="n">vptr</span><span class="p">;</span>
	<span class="n">nleft</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="n">nleft</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span><span class="p">(</span> <span class="p">(</span><span class="n">nread</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">nleft</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span><span class="p">(</span><span class="n">errno</span> <span class="o">==</span> <span class="n">EINTR</span><span class="p">)</span> <span class="c1">// read 시스템콜을 수행하는 도중에 인터럽트가 발생한 경우(read 도중에 인터럽트가 발생하면 errno 에 EINTR 가 세팅된다.)</span>
				<span class="n">nread</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 다시 read 를 호출하도록 초기화한다.</span>
			<span class="k">else</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nread</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> 
			<span class="k">break</span><span class="p">;</span>  <span class="c1">// EOF 를 만난 경우</span>
		
		<span class="n">nleft</span> <span class="o">-=</span> <span class="n">nread</span><span class="p">;</span> <span class="c1">// 얼마나 더 읽어들여야하는지 남은 바이트 수를 갱신한다.</span>
		<span class="n">ptr</span> <span class="o">+=</span> <span class="n">nread</span><span class="p">;</span>  <span class="c1">// 읽어들인 수만큼 포인터를 전진시킨다.</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">nleft</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">ssize_t</span>
<span class="nf">writen</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">vptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span> 
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">nleft</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">nwritten</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
	
	<span class="n">ptr</span> <span class="o">=</span> <span class="n">vptr</span><span class="p">;</span>
	<span class="n">nleft</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="n">nleft</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span><span class="p">(</span> <span class="p">(</span><span class="n">nwritten</span> <span class="o">=</span> <span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">nleft</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span><span class="p">(</span><span class="n">nwritten</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">errno</span> <span class="o">==</span> <span class="n">EINTR</span><span class="p">)</span>
				<span class="n">nwritten</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 다시 write 를 호출하도록 초기화한다.</span>
			<span class="k">else</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">nleft</span> <span class="o">-=</span> <span class="n">nwritten</span><span class="p">;</span>
		<span class="n">ptr</span> <span class="o">+=</span> <span class="n">nwritten</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">ssize_t</span>
<span class="nf">readline</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">vptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">maxlen</span><span class="p">)</span> 
<span class="p">{</span>
	<span class="kt">ssize_t</span> <span class="n">n</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">c</span><span class="p">,</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
	
	<span class="n">ptr</span> <span class="o">=</span> <span class="n">vptr</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">maxlen</span><span class="p">;</span> <span class="o">++</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
		<span class="nl">again:</span>
			<span class="k">if</span><span class="p">(</span> <span class="p">(</span><span class="n">rc</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">ptr</span><span class="o">++</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
				<span class="k">if</span><span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">'\n'</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">return</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">if</span><span class="p">(</span><span class="n">errno</span> <span class="o">==</span> <span class="n">EINTR</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
				<span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
			<span class="p">}</span>
	<span class="p">}</span>
	
	<span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

</article>

<!-- buy me a coffee -->
<style>.bmc-button img{width: 27px !important;margin-bottom: 1px !important;box-shadow: none !important;border: none !important;vertical-align: middle !important;}.bmc-button{line-height: 36px !important;height:37px !important;text-decoration: none !important;display:inline-flex !important;color:#ffffff !important;background-color:#BB5794 !important;border-radius: 3px !important;border: 1px solid transparent !important;padding: 1px 9px !important;font-size: 22px !important;letter-spacing:0.6px !important;box-shadow: 0px 1px 2px rgba(190, 190, 190, 0.5) !important;-webkit-box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;margin: 0 auto !important;font-family:'Cookie', cursive !important;-webkit-box-sizing: border-box !important;box-sizing: border-box !important;-o-transition: 0.3s all linear !important;-webkit-transition: 0.3s all linear !important;-moz-transition: 0.3s all linear !important;-ms-transition: 0.3s all linear !important;transition: 0.3s all linear !important;}.bmc-button:hover, .bmc-button:active, .bmc-button:focus {-webkit-box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;text-decoration: none !important;box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;opacity: 0.85 !important;color:#ffffff !important;}</style><link href="https://fonts.googleapis.com/css?family=Cookie" rel="stylesheet">

<div class="text-center my-4">
    <a class="bmc-button" target="_blank" href="https://qr.kakaopay.com/Ej8T6e8CM5dc06009"><img src="https://www.buymeacoffee.com/assets/img/BMC-btn-logo.svg" alt="Buy me a coffee"><span style="margin-left:5px">Buy me a coffee</span></a>
</div>
<script src="https://utteranc.es/client.js"
    repo="kodingwarrior/kodingwarrior.github.io"
    issue-term="title"
    theme="github-light"
    crossorigin="anonymous"
    async>
</script>
      </article>
    </main>

    <footer class="flex justify-start sm:justify-center flex-col sm:flex-row">
  <a class="my-2 mx-3 no-underline" href="/rss.xml">
    <i class="bi bi-rss-fill text-2xl"></i> Feed
  </a>
  <a class="my-2 mx-3 no-underline" href="mailto:rijgndqw012@gmail.com">
    <i class="bi bi-envelope-fill text-2xl"></i> Email
  </a>
  <a class="my-2 mx-3 no-underline" href="https://twitter.com/kodingwarrior">
    <i class="bi bi-twitter text-2xl"></i> Twitter
  </a>
  <a class="my-2 mx-3 no-underline" href="https://github.com/kodingwarrior/kodingwarrior.github.io">
    <i class="bi bi-github text-2xl"></i> Github
  </a>
</footer>


    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-127979309-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-127979309-1');
    </script>
  </body>
</html>
