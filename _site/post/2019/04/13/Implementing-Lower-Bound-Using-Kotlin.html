<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Kotlin으로 C++의 lower_bound, upper_bound 함수 구현하기 | KODINGWARRIOR QUEST</title>
<meta name="generator" content="Jekyll v3.8.3" />
<meta property="og:title" content="Kotlin으로 C++의 lower_bound, upper_bound 함수 구현하기" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="TL;DR lower_bound, upper_bound를 구현할 때 반열린 구간 Notation을 지키는 것이 좋다. lower_bound 구현하기 이분탐색을 수행하듯이 lo, mid, hi 파라미터를 반복문 돌려가면서 적당히 조정한다.(while(lo &lt; hi)) mid가 가리키는 값이 value보다 작으면(elements[mid] &lt; value), 탐색해야 하는 범위가 뒤쪽에 있다고 가정한다. → lo = mid + 1 mid가 가리키는 값이 value보다 크거나 같으면(elements[mid] ≥ value), 탐색해야 하는 범위는 좁혀진다.(high = mid) 탐색에 성공하여 value 이상의 값이 처음 나타나는 위치를 발견하게 된다면, 탐색 범위가 좁혀진 lo(==hi)를 반환한다. 탐색에 실패하여 mid가 포함되지 않는 구간인 high에 도달하게 된다면, 없다고 가정하고 high를 반환한다. upper_bound 구현하기 이분탐색을 수행하듯이 lo, mid, hi 파라미터를 반복문 돌려가면서 적당히 조정한다.(while(lo &lt; hi)) mid가 가리키는 값이 value보다 작거나 같으면(elements[mid] &lt;= value), 탐색해야 하는 범위가 뒤쪽에 있다고 가정한다. → lo = mid + 1 mid가 가리키는 값이 value보다 크면(elements[mid] &gt; value), 탐색해야 하는 범위는 좁혀진다.(high = mid) 탐색에 성공하여 value를 넘는 값이 처음 나타나는 위치를 발견하게 된다면, 탐색 범위가 좁혀진 lo(==hi)를 반환한다. mid가 포함되지 않는 구간인 high에 도달하게 된다면, 없다고 가정하고 high를 반환한다. Kotlin 믿고 잡숴보시라" />
<meta property="og:description" content="TL;DR lower_bound, upper_bound를 구현할 때 반열린 구간 Notation을 지키는 것이 좋다. lower_bound 구현하기 이분탐색을 수행하듯이 lo, mid, hi 파라미터를 반복문 돌려가면서 적당히 조정한다.(while(lo &lt; hi)) mid가 가리키는 값이 value보다 작으면(elements[mid] &lt; value), 탐색해야 하는 범위가 뒤쪽에 있다고 가정한다. → lo = mid + 1 mid가 가리키는 값이 value보다 크거나 같으면(elements[mid] ≥ value), 탐색해야 하는 범위는 좁혀진다.(high = mid) 탐색에 성공하여 value 이상의 값이 처음 나타나는 위치를 발견하게 된다면, 탐색 범위가 좁혀진 lo(==hi)를 반환한다. 탐색에 실패하여 mid가 포함되지 않는 구간인 high에 도달하게 된다면, 없다고 가정하고 high를 반환한다. upper_bound 구현하기 이분탐색을 수행하듯이 lo, mid, hi 파라미터를 반복문 돌려가면서 적당히 조정한다.(while(lo &lt; hi)) mid가 가리키는 값이 value보다 작거나 같으면(elements[mid] &lt;= value), 탐색해야 하는 범위가 뒤쪽에 있다고 가정한다. → lo = mid + 1 mid가 가리키는 값이 value보다 크면(elements[mid] &gt; value), 탐색해야 하는 범위는 좁혀진다.(high = mid) 탐색에 성공하여 value를 넘는 값이 처음 나타나는 위치를 발견하게 된다면, 탐색 범위가 좁혀진 lo(==hi)를 반환한다. mid가 포함되지 않는 구간인 high에 도달하게 된다면, 없다고 가정하고 high를 반환한다. Kotlin 믿고 잡숴보시라" />
<link rel="canonical" href="http://localhost:4000/post/2019/04/13/Implementing-Lower-Bound-Using-Kotlin.html" />
<meta property="og:url" content="http://localhost:4000/post/2019/04/13/Implementing-Lower-Bound-Using-Kotlin.html" />
<meta property="og:site_name" content="KODINGWARRIOR QUEST" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-04-13T16:31:00+09:00" />
<script type="application/ld+json">
{"description":"TL;DR lower_bound, upper_bound를 구현할 때 반열린 구간 Notation을 지키는 것이 좋다. lower_bound 구현하기 이분탐색을 수행하듯이 lo, mid, hi 파라미터를 반복문 돌려가면서 적당히 조정한다.(while(lo &lt; hi)) mid가 가리키는 값이 value보다 작으면(elements[mid] &lt; value), 탐색해야 하는 범위가 뒤쪽에 있다고 가정한다. → lo = mid + 1 mid가 가리키는 값이 value보다 크거나 같으면(elements[mid] ≥ value), 탐색해야 하는 범위는 좁혀진다.(high = mid) 탐색에 성공하여 value 이상의 값이 처음 나타나는 위치를 발견하게 된다면, 탐색 범위가 좁혀진 lo(==hi)를 반환한다. 탐색에 실패하여 mid가 포함되지 않는 구간인 high에 도달하게 된다면, 없다고 가정하고 high를 반환한다. upper_bound 구현하기 이분탐색을 수행하듯이 lo, mid, hi 파라미터를 반복문 돌려가면서 적당히 조정한다.(while(lo &lt; hi)) mid가 가리키는 값이 value보다 작거나 같으면(elements[mid] &lt;= value), 탐색해야 하는 범위가 뒤쪽에 있다고 가정한다. → lo = mid + 1 mid가 가리키는 값이 value보다 크면(elements[mid] &gt; value), 탐색해야 하는 범위는 좁혀진다.(high = mid) 탐색에 성공하여 value를 넘는 값이 처음 나타나는 위치를 발견하게 된다면, 탐색 범위가 좁혀진 lo(==hi)를 반환한다. mid가 포함되지 않는 구간인 high에 도달하게 된다면, 없다고 가정하고 high를 반환한다. Kotlin 믿고 잡숴보시라","@type":"BlogPosting","headline":"Kotlin으로 C++의 lower_bound, upper_bound 함수 구현하기","dateModified":"2019-04-13T16:31:00+09:00","datePublished":"2019-04-13T16:31:00+09:00","url":"http://localhost:4000/post/2019/04/13/Implementing-Lower-Bound-Using-Kotlin.html","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/post/2019/04/13/Implementing-Lower-Bound-Using-Kotlin.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="KODINGWARRIOR QUEST" /><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({
    google_ad_client: "ca-pub-1921128237875891",
    enable_page_level_ads: true
    });
  </script>
  
</head>



  <body>
     <header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">KODINGWARRIOR QUEST</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>


     <main class="page-content">
       <div class="wrapper">
	 <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Kotlin으로 C++의 lower_bound, upper_bound 함수 구현하기</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2019-04-13T16:31:00+09:00" itemprop="datePublished">Apr 13, 2019
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <ul class="section-nav">
<li class="toc-entry toc-h2"><a href="#kotlin으로-ps를-하면서-느낀-점">Kotlin으로 PS를 하면서 느낀 점</a>
<ul>
<li class="toc-entry toc-h3"><a href="#좋았던-점">좋았던 점</a></li>
<li class="toc-entry toc-h3"><a href="#아쉬웠던-점">아쉬웠던 점</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#없으면-직접-만들어야지-뭐">없으면 직접 만들어야지, 뭐…</a>
<ul>
<li class="toc-entry toc-h3"><a href="#lower_bound">lower_bound</a></li>
<li class="toc-entry toc-h3"><a href="#upper_bound">upper_bound</a></li>
<li class="toc-entry toc-h3"><a href="#equal_range">equal_range</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#마치며">마치며</a></li>
</ul><blockquote>
  <p>TL;DR</p>
  <ul>
    <li>
      <p><strong><code class="highlighter-rouge">lower_bound</code></strong>, <strong><code class="highlighter-rouge">upper_bound</code></strong>를 구현할 때 반열린 구간 Notation을 지키는 것이 좋다.</p>
    </li>
    <li>
<strong><code class="highlighter-rouge">lower_bound</code></strong> 구현하기
      <ol>
        <li>이분탐색을 수행하듯이 lo, mid, hi 파라미터를 반복문 돌려가면서 적당히 조정한다.(<strong><code class="highlighter-rouge">while(lo &lt; hi)</code></strong>)</li>
        <li>mid가 가리키는 값이 <strong>value보다 작으면(<code class="highlighter-rouge">elements[mid] &lt; value</code>)</strong>, 탐색해야 하는 범위가 뒤쪽에 있다고 가정한다. → <strong><code class="highlighter-rouge">lo = mid + 1</code></strong>
</li>
        <li>mid가 가리키는 값이 <strong>value보다 크거나 같으면</strong>(<strong><code class="highlighter-rouge">elements[mid] ≥ value</code></strong>),  탐색해야 하는 범위는 좁혀진다.(<strong><code class="highlighter-rouge">high = mid</code></strong>)</li>
        <li>탐색에 성공하여 value 이상의 값이 처음 나타나는 위치를 발견하게 된다면, 탐색 범위가 좁혀진 <strong><code class="highlighter-rouge">lo</code></strong>(==<strong><code class="highlighter-rouge">hi</code></strong>)를 반환한다.</li>
        <li>탐색에 실패하여 mid가 포함되지 않는 구간인 high에 도달하게 된다면, 없다고 가정하고 high를 반환한다.</li>
      </ol>
    </li>
    <li>
<strong><code class="highlighter-rouge">upper_bound</code></strong> 구현하기
      <ol>
        <li>이분탐색을 수행하듯이 lo, mid, hi 파라미터를 반복문 돌려가면서 적당히 조정한다.(<strong><code class="highlighter-rouge">while(lo &lt; hi)</code></strong>)</li>
        <li>mid가 가리키는 값이 <strong>value보다 작거나 같으면(<code class="highlighter-rouge">elements[mid] &lt;= value</code></strong>), 탐색해야 하는 범위가 뒤쪽에 있다고 가정한다. → <strong><code class="highlighter-rouge">lo = mid + 1</code></strong>
</li>
        <li>mid가 가리키는 값이 <strong>value보다 크면</strong>(<strong><code class="highlighter-rouge">elements[mid] &gt; value</code></strong>), 탐색해야 하는 범위는 좁혀진다.(<strong><code class="highlighter-rouge">high = mid</code></strong>)</li>
        <li>탐색에 성공하여 value를 넘는 값이 처음 나타나는 위치를 발견하게 된다면, 탐색 범위가 좁혀진 <strong><code class="highlighter-rouge">lo</code></strong>(==<strong><code class="highlighter-rouge">hi</code></strong>)를 반환한다.</li>
        <li>mid가 포함되지 않는 구간인 high에 도달하게 된다면, 없다고 가정하고 high를 반환한다.</li>
      </ol>
    </li>
    <li>
<strong>Kotlin</strong> 믿고 잡숴보시라</li>
  </ul>
</blockquote>

<p>이 글에서는 <strong>Kotlin</strong>을 이용해서, <strong>C++</strong>의 STL에서 제공되는 <strong><code class="highlighter-rouge">lower_bound</code></strong>, <strong><code class="highlighter-rouge">upper_bound</code></strong> 함수를 어떻게 구현하게 되었는지 공유하고자 한다.</p>

<p>프로그래밍 대회 준비/학회 내부 알고리즘 교육 때문에 <strong>C++</strong>로 알고리즘 문제를 풀어왔었지만, 학부 생활을 벗어나니 <strong>C++</strong>를 쓸 일도 없어졌다. <strong>웹 개발자</strong>로서 주로 접하게 되는 언어는 <strong>Java</strong>, <strong>Python</strong>, <strong>Ruby</strong>, <strong>Javascript</strong> 정도 밖에 되지 않는다. 그 중에서도 <a href="https://acmicpc.net">Baekjoon Online Judge</a>에서 대부분의 알고리즘 문제를 풀 수 있으려면 가장 무난한 언어가 <strong>Java</strong>였다.</p>

<p><strong><code class="highlighter-rouge">Java로 알고리즘 문제 푸는 걸 연습해야겠다</code></strong>고 결심이 들던 와중 <a href="https://www.acmicpc.net/blog/view/71">이런 글</a>을 발견했다. <strong>Kotlin</strong>을 이용해서 알고리즘 문제를 푸는 방법을 기초적인 수준에서 설명하는 글이다. 뒤에서 설명하겠지만, <strong>Java</strong>로 알고리즘 문제를 푸는 행위에 회의감을 느끼던 나에게는 상당히 흥미롭게 느껴졌고, <a href="https://shiftpsh.com/">저자 분</a>에게 직접 이것저것 물어보면서 <strong>Kotlin</strong>으로 알고리즘 문제를 푸는 방법을 연마하는 중이다.</p>

<h2 id="kotlin으로-ps를-하면서-느낀-점">
<a id="kotlin으로-ps를-하면서-느낀-점" class="anchor" href="#kotlin%EC%9C%BC%EB%A1%9C-ps%EB%A5%BC-%ED%95%98%EB%A9%B4%EC%84%9C-%EB%8A%90%EB%82%80-%EC%A0%90" aria-hidden="true"><span class="octicon octicon-link"></span></a>Kotlin으로 PS를 하면서 느낀 점</h2>

<p>대략 <strong>4월 초</strong>부터 <strong>Kotlin</strong>으로 알고리즘 문제를 풀기 시작했다. <strong>C++</strong>가 아닌 언어로 알고리즘 문제를 풀어놓은 흔적을 남겨놓은 <a href="https://github.com/malkoG/polyglot-cp">리포지토리</a>를 한달 전부터 유지하고 있는데, <code class="highlighter-rouge">.kt</code> 확장자가 보인다면 <strong><code class="highlighter-rouge">이게 Kotlin으로 풀이한거구나</code></strong>하고 이해하면 된다.</p>

<p><strong><code class="highlighter-rouge">Kotlin</code></strong>으로 알고리즘 문제를 풀게 된 건 그렇게 오래되지는 않았지만, 1주~2주의 짧은 기간 동안 건드리면서 느꼈던 점들을 간단하게 아래에서 정리했다.</p>

<h3 id="좋았던-점">
<a id="좋았던-점" class="anchor" href="#%EC%A2%8B%EC%95%98%EB%8D%98-%EC%A0%90" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>좋았던 점</strong>
</h3>

<ul>
  <li>
<strong>Java</strong>와 100% 호환되기 때문에, <strong>Java</strong>에서 제공하는 클래스를 그대로 끌어다 쓸 수 있다. (컨테이너 클래스는 <strong>C++</strong> 못지 않다)</li>
  <li>
<strong>Java</strong>로 코딩하는 방식에 비해, 불편한 점이 상당히 줄었다.
    <ul>
      <li>
<strong><code class="highlighter-rouge">Pair</code></strong>, <strong><code class="highlighter-rouge">Triple</code></strong> 자료구조를 지원한다.  (<strong>Java</strong>에서는 이런 자료구조까지 클래스와 생성자로 직접 정의해야 했고, 정렬할 때도 정렬 함수를 따로 정의해줘야 하는 불편함이 있다. 하지만 코틀린에서는? 그런거 없다. 이미 만들어져 있고, 생성자도 잘 정의되어 있고, 정렬 함수도 납득할만한 수준으로 잘 정의되어 있다. <strong>C++</strong>에서 옮겨와도 크게 불편함이 없을 수준이다.)</li>
      <li>디폴트 파라미터를 지원한다.</li>
      <li>연산자 오버로딩을 지원한다. (<strong>Java</strong>에서는 <strong><code class="highlighter-rouge">ArrayList</code></strong> 컬렉션에 random access를 할 때, <code class="highlighter-rouge">.at(idx)</code> 노테이션을 이용해서 접근해야 하는 불편함이 있었지만, <strong>Kotlin</strong>에서는 random access를 할 때 <code class="highlighter-rouge">[idx]</code> 노테이션으로 접근하기만 하면 된다. <strong><code class="highlighter-rouge">String</code></strong>도 마찬가지로 적용된다.)</li>
      <li>
<strong><code class="highlighter-rouge">typealias</code></strong>를 지원한다. (<strong>Java</strong>는 상속으로 흉내내야 한다.)</li>
      <li>불필요한 OOP 문법을 적용하지 않아도 된다.(<strong>Kotlin</strong>으로 문제 풀면서 <strong><code class="highlighter-rouge">public static class</code></strong> 이런걸 거의 보지 않았던 것 같다.)</li>
    </ul>
  </li>
  <li>
<strong>C++</strong> 최신 표준 못지 않게 현대적인 문법이 많이 제공된다. (destructuring, 메서드 연쇄 중 어딘가에서 null이 튀어나오면 null을 리턴하는 등 Optional type에 대한 우아한 처리)</li>
</ul>

<h3 id="아쉬웠던-점">
<a id="아쉬웠던-점" class="anchor" href="#%EC%95%84%EC%89%AC%EC%9B%A0%EB%8D%98-%EC%A0%90" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>아쉬웠던 점</strong>
</h3>

<ul>
  <li>
<strong>C++</strong>에 비해 제공되는 함수가 적다. 정확히는, 필요한데 제공되지 않는 함수들이 있어서 빈자리가 느껴진다.(<strong><code class="highlighter-rouge">lower_bound/upper_bound</code></strong> 등 이분 탐색을 응용한 함수, <strong><code class="highlighter-rouge">next_permutation/prev_permutation</code></strong> 등 순열을 다루는 함수)</li>
  <li>컴파일 속도가 좀 느리다.</li>
  <li>
<strong>Java</strong>와 100% 호환이 되는 건 좋지만, 공식 문서가 모자란 것 같다는 느낌이 든다. (<strong>Java</strong> 공식 문서를 더 많이 봤던 것 같다.)</li>
</ul>

<h2 id="없으면-직접-만들어야지-뭐">
<a id="없으면-직접-만들어야지-뭐" class="anchor" href="#%EC%97%86%EC%9C%BC%EB%A9%B4-%EC%A7%81%EC%A0%91-%EB%A7%8C%EB%93%A4%EC%96%B4%EC%95%BC%EC%A7%80-%EB%AD%90" aria-hidden="true"><span class="octicon octicon-link"></span></a>없으면 직접 만들어야지, 뭐…</h2>

<p>알고리즘 문제 중에는 이분탐색으로 분류된 여러가지 문제가 있는데, 이분탐색으로 분류된 문제 중에는 <strong><code class="highlighter-rouge">lower_bound</code></strong>, <strong><code class="highlighter-rouge">upper_bound</code></strong> 함수를 이용해야만 편리하게 풀 수 있는 문제들이 있다. 하지만, 위에서 언급했다시피 <strong>Kotlin에서는 이런 함수를 가져다 쓸 수가 없다</strong>. 그러면 뭐다? 직접 만들어야지.</p>

<h3 id="lower_bound">
<a id="lower_bound" class="anchor" href="#lower_bound" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>lower_bound</strong>
</h3>

<blockquote>
  <p>C++에서 <strong><code class="highlighter-rouge">lower_bound</code></strong> 함수를 어떻게 활용하는지는 <a href="https://en.cppreference.com/w/cpp/algorithm/lower_bound">여기</a>에서 볼 수 있다.</p>
</blockquote>

<p><strong><code class="highlighter-rouge">lower_bound</code></strong>는 정렬된 리스트 내에서 특정 값 이상의 값이 처음 나타나는 위치를 반환하는 함수로 구현되어야 한다. 일단, 구현되는 원리는 이분탐색에서 기반한 거라고 주워들은 게 있었기 때문에, <strong>Parametric Search</strong>를 적용하던 방식을 떠올리기 시작했다.</p>

<p><strong>Parametric Search</strong>는 어떤 값이 정답일 지 알 수 없지만, <strong>결과값 y</strong>가 결정되어 있을 때 <strong><code class="highlighter-rouge">f(x) = y</code></strong> 식을 만족하도록 이분탐색으로 solution이 될 수 있는 범위를 좁혀가면서 solution x의 최솟값/최댓값을 구하는데 쓰이는 알고리즘이다. <strong>Parametric Search</strong>를 적용할 수 있으려면, 적용되는 함수가 <strong>단조증가함수</strong>이거나 <strong>단조감소함수</strong>여야 한다는 제약이 있다.</p>

<p>함수 <strong><code class="highlighter-rouge">f(x)</code></strong>가 <strong>단조증가함수</strong>라고 가정해보자. <strong>Parametric Search</strong>는 이런 조건에서 아래와 같이 구현할 수 있다.</p>

<blockquote>
  <p>i) <strong><code class="highlighter-rouge">f(x1) &lt; y</code></strong>일 경우, <strong><code class="highlighter-rouge">f(x)</code></strong>는 <strong>단조증가함수</strong>이기 때문에 <strong>해답이 되는 x는 x1보다 뒤에 있다</strong>고 생각할 수 있다.
ii) <strong><code class="highlighter-rouge">f(x1) &gt; y</code></strong>일 경우, <strong><code class="highlighter-rouge">f(x)</code></strong>는 <strong>단조증가함수</strong>이기 때문에 <strong>해답이 되는 x는 x1보다 앞에 있다</strong>고 생각할 수 있다.
iii) 특정구간에서 계단함수로 나타날 가능성이 있기 때문에, <strong><code class="highlighter-rouge">f(x1) = y</code></strong>일 때, 탐색범위가 하나로 좁혀질때까지 탐색범위를 줄여나간다.</p>
</blockquote>

<p><strong><code class="highlighter-rouge">lower_bound</code></strong>도 어떻게 보면 <strong>Parametric Search</strong>의 응용이라고 볼 수 있는데, 해의 범위는 조사를 시작하는 인덱스 low와 조사를 끝내는 인덱스 high 사이이며, 적용되는 함수는 인자로 넘겨진 배열 <strong><code class="highlighter-rouge">elements</code></strong>에 random access한 값이다. 이분탐색을 적용할 수 있으려면, <strong>“<code class="highlighter-rouge">elements</code>는 오름차순으로 정렬되어 있어야 한다”</strong>라는 전제조건이 있기 때문에, <strong>단조증가</strong>일 수 밖에 없다. 따라서, <strong><code class="highlighter-rouge">lower_bound</code></strong>도 <strong>Parametric Search</strong>처럼 구현이 가능하다.</p>

<p><strong>Parametric Search</strong>의 구현원리를 이용하여 <strong>Kotlin</strong>으로 <strong><code class="highlighter-rouge">lower_bound</code></strong> 함수를 구현한 코드는 아래와 같다.</p>
<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typealias</span> <span class="n">Index</span> <span class="p">=</span> <span class="n">Int</span>

<span class="k">fun</span> <span class="n">lower_bound</span><span class="p">(</span><span class="n">elements</span><span class="p">:</span> <span class="n">ArrayList</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;,</span>
		<span class="n">low</span><span class="p">:</span> <span class="n">Index</span><span class="p">,</span> <span class="n">high</span><span class="p">:</span> <span class="n">Index</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">:</span> <span class="n">Index</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="py">lo</span> <span class="p">=</span> <span class="n">low</span>
	<span class="kd">var</span> <span class="py">hi</span> <span class="p">=</span> <span class="n">high</span>
	<span class="kd">var</span> <span class="py">mid</span><span class="p">:</span> <span class="n">Index</span> <span class="p">=</span> <span class="n">high</span>
	<span class="k">while</span><span class="p">(</span><span class="n">lo</span> <span class="p">&lt;</span> <span class="n">hi</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mid</span> <span class="p">=</span> <span class="p">(</span><span class="n">lo</span> <span class="p">+</span> <span class="n">hi</span><span class="p">)</span> <span class="n">shr</span> <span class="m">1</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mid</span> <span class="p">==</span> <span class="n">high</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">high</span>

		<span class="k">if</span><span class="p">(</span><span class="n">elements</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="p">&lt;</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// value보다 작은 값을 만난 경우</span>
			<span class="n">lo</span> <span class="p">=</span> <span class="n">mid</span> <span class="p">+</span> <span class="m">1</span>            <span class="c1">// 탐색해야 하는 범위가 뒤쪽에 있다고 가정</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>                    <span class="c1">// value보다 크거나 같은 값을 만난 경우</span>
			<span class="n">hi</span> <span class="p">=</span> <span class="n">mid</span>                <span class="c1">// 탐색해야 하는 범위가 안쪽에 있다고 가정</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">lo</span>                     <span class="c1">// 맨 왼쪽 범위가 처음 나타나는 위치를 의미</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="upper_bound">
<a id="upper_bound" class="anchor" href="#upper_bound" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>upper_bound</strong>
</h3>

<blockquote>
  <p>C++에서 <strong><code class="highlighter-rouge">upper_bound</code></strong> 함수를 어떻게 활용하는지는 <a href="https://en.cppreference.com/w/cpp/algorithm/upper_bound">여기</a>에서 볼 수 있다.</p>
</blockquote>

<p><strong><code class="highlighter-rouge">upper_bound</code></strong>는 정렬된 리스트 내에서 특정 값을 넘는 값이 처음 나타나는 위치를 반환하는 함수로 구현되어야 한다. <strong><code class="highlighter-rouge">upper_bound</code></strong>는 <strong><code class="highlighter-rouge">lower_bound</code></strong>와 비슷하게 <strong><code class="highlighter-rouge">Parametric Search</code></strong>처럼 구현 가능하다.. 다만, 특정 원소보다 크거나 같은 값이 처음으로 나타나는 위치가 아닌 특정 원소보다 큰 값이 처음으로 나타나는 위치를 반환해야 하기 때문에, <strong><code class="highlighter-rouge">elements</code></strong>에 random access한 값이 찾고자 하는 값보다 작거나 같다면, 탐색해야 하는 범위는 뒤쪽에 있다고 가정해야 한다.</p>

<p><strong><code class="highlighter-rouge">Parametric Search</code></strong>의 구현원리를 이용하여 <strong><code class="highlighter-rouge">Kotlin</code></strong>으로 <strong><code class="highlighter-rouge">upper_bound</code></strong> 함수를 구현한 코드는 아래와 같다. <strong><code class="highlighter-rouge">lower_bound</code></strong>와 비슷하지만, 등호 부분만 바꿔주면 된다.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typealias</span> <span class="n">Index</span> <span class="p">=</span> <span class="n">Int</span>

<span class="k">fun</span> <span class="n">upper_bound</span><span class="p">(</span><span class="n">elements</span><span class="p">:</span> <span class="n">ArrayList</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;,</span>
		<span class="n">low</span><span class="p">:</span> <span class="n">Index</span><span class="p">,</span> <span class="n">high</span><span class="p">:</span> <span class="n">Index</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">:</span> <span class="n">Index</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="py">lo</span> <span class="p">=</span> <span class="n">low</span>
	<span class="kd">var</span> <span class="py">hi</span> <span class="p">=</span> <span class="n">high</span>
	<span class="kd">var</span> <span class="py">mid</span><span class="p">:</span> <span class="n">Index</span> <span class="p">=</span> <span class="n">high</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">lo</span> <span class="p">&lt;</span> <span class="n">hi</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mid</span> <span class="p">=</span> <span class="p">(</span><span class="n">lo</span> <span class="p">+</span> <span class="n">hi</span><span class="p">)</span> <span class="n">shr</span> <span class="m">1</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mid</span> <span class="p">==</span> <span class="n">high</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">high</span>

		<span class="k">if</span><span class="p">(</span><span class="n">elements</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="p">&lt;=</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// value보다 작거나 같은 값을 만난 경우</span>
			<span class="n">lo</span> <span class="p">=</span> <span class="n">mid</span> <span class="p">+</span> <span class="m">1</span>              <span class="c1">// 탐색 범위가 뒤쪽에 있다고 가정</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>                      <span class="c1">// value보다 큰 값을 만난 경우</span>
			<span class="n">hi</span> <span class="p">=</span> <span class="n">mid</span>                  <span class="c1">// 탐색 범위가 안쪽에 있다고 가정</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">lo</span>                       <span class="c1">// 맨 왼쪽 범위가 처음 나타나는 위치를 의미</span>
<span class="p">}</span>
</code></pre></div></div>
<h3 id="equal_range">
<a id="equal_range" class="anchor" href="#equal_range" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>equal_range</strong>
</h3>

<blockquote>
  <p>C++에서 <strong><code class="highlighter-rouge">equal_range</code></strong> 함수를 어떻게 활용하는지는 <a href="https://en.cppreference.com/w/cpp/algorithm/equal_range">여기</a>에서 볼 수 있다.</p>
</blockquote>

<p><strong><code class="highlighter-rouge">equal_range</code></strong>는 정렬된 리스트 내에서 특정 값이 나타나는 구간을 반열린 구간으로 반환하는 함수로 구현되어야 한다. <strong><code class="highlighter-rouge">equal_range</code></strong>를 구현하는 건 그렇게 어렵지 않다. <strong><code class="highlighter-rouge">lower_bound</code></strong>, <strong><code class="highlighter-rouge">upper_bound</code></strong>로 구성된 <strong><code class="highlighter-rouge">Pair</code></strong>를 반환하면 그만이다.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typealias</span> <span class="n">Index</span> <span class="p">=</span> <span class="n">Int</span>

<span class="c1">// equal_range는 정렬된 리스트의 [low, high) 구간 사이에서 특정 값이 나타나는 구간을 Pair로 반환한다.</span>
<span class="c1">// lower_bound == upper_bound일 경우, value가 나타나는 구간은 없다고 가정한다.</span>
<span class="c1">// low : 조사를 시작하는 구간(닫힌 구간) - 포함</span>
<span class="c1">// high : 조사를 끝내는 구간(열린 구간) - 미포함</span>
<span class="c1">// value : 조사할 값</span>
<span class="k">fun</span> <span class="n">equal_range</span><span class="p">(</span><span class="n">elements</span><span class="p">:</span> <span class="n">ArrayList</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;,</span>
		<span class="n">low</span><span class="p">:</span> <span class="n">Index</span><span class="p">,</span> <span class="n">high</span><span class="p">:</span> <span class="n">Index</span><span class="p">,</span>  <span class="n">value</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">:</span> <span class="n">Pair</span><span class="p">&lt;</span><span class="n">Index</span><span class="p">,</span><span class="n">Index</span><span class="p">&gt;</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">Pair</span><span class="p">(</span><span class="n">lower_bound</span><span class="p">(</span><span class="n">elements</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">value</span><span class="p">),</span> <span class="n">upper_bound</span><span class="p">(</span><span class="n">elements</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">val</span> <span class="err">(</span><span class="py">lower</span><span class="p">,</span><span class="n">upper</span><span class="p">)</span> <span class="p">=</span> <span class="n">equal_range</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span> 
</code></pre></div></div>

<h2 id="마치며">
<a id="마치며" class="anchor" href="#%EB%A7%88%EC%B9%98%EB%A9%B0" aria-hidden="true"><span class="octicon octicon-link"></span></a>마치며</h2>

<p><strong>Kotlin</strong>을 개발한 JetBrain에서 ACM-ICPC(세계 대학생 프로그래밍 대회)를 후원하고 있다. <a href="https://blog.jetbrains.com/kr/2017/06/jetbrains-acm-icpc-%EA%B3%B5%EC%8B%9D-%ED%9B%84%EC%9B%90/">ACM-ICPC 공식 페이지에서도 Kotlin을 지원하게 될 것</a>이라고 밝혔기 때문에, <strong><code class="highlighter-rouge">Kotlin을 이용한 알고리즘 문제 풀이</code></strong>에 대한 수요는 계속해서 증가할 것이라 본다.</p>

<p>하지만, 아직까지는 국내에 <strong>Kotlin</strong>을 이용해서 알고리즘 문제를 풀이하는 방법을 소개하는 리소스가 많지 않다. <strong>Kotlin</strong>이라는 언어가 아직까지는 <strong><code class="highlighter-rouge">Java에 대한 배경지식을 요구한다는 인식</code></strong>이 지배적이며, <strong>Kotlin</strong>이 정규 교과과정에 들어가는 언어도 아니다보니 따로 공부하는 사람만 알고 있는 편이다.</p>

<p>국내에서 출판된 <strong>Kotlin</strong> 도서도 <strong>Java</strong>에 대한 배경지식이 있다고 가정하고 쓰여진 책이 여럿 있다보니, <strong><code class="highlighter-rouge">"Kotlin을 하려면 Java를 알아야 한다"</code></strong>가 통념이 되어버리는 것 같다. <strong><code class="highlighter-rouge">C++를 알기 위해서, C를 알고 있어야 한다</code></strong>는 논리처럼 보여지기도 하지만, 나도 역시 <strong>Java</strong>를 어느 정도 공부하고 나서 <strong>Kotlin</strong>을 영접한 케이스이고, 개인차가 있는 것 같으니 확실히 답하기는 어렵다.</p>

<p>그럼에도, <strong>Kotlin</strong>은 정말 배우기 쉬운 편이며, 문법이 다른 언어 못지 않게 간결하며, 배울만한 가치가 있다. 지금 당장은 암흑기라고 판단되지만, 조만간 대중적인 언어로서 주가가 크게 상승할 것이라고 강하게 촉이 오는 언어는 <strong>Kotlin</strong>이 처음이었다. 대중적으로 쓰이는 <strong>Java</strong>와 100% 호환이 되며, <strong>Java</strong>와 비슷하면서도 <strong>Java</strong>보다 문법이 훨씬 간결하고 편의 문법이 여럿 제공되는데 <strong>Kotlin</strong>을 선택하지 않을 이유가 무엇이란 말인가?</p>

<p><strong>Kotlin</strong>, 한번 믿고 잡숴보시라.</p>

  </div>

  <!-- buy me a coffee -->
  <style>.bmc-button img{width: 27px !important;margin-bottom: 1px !important;box-shadow: none !important;border: none !important;vertical-align: middle !important;}.bmc-button{line-height: 36px !important;height:37px !important;text-decoration: none !important;display:inline-flex !important;color:#ffffff !important;background-color:#BB5794 !important;border-radius: 3px !important;border: 1px solid transparent !important;padding: 1px 9px !important;font-size: 22px !important;letter-spacing:0.6px !important;box-shadow: 0px 1px 2px rgba(190, 190, 190, 0.5) !important;-webkit-box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;margin: 0 auto !important;font-family:'Cookie', cursive !important;-webkit-box-sizing: border-box !important;box-sizing: border-box !important;-o-transition: 0.3s all linear !important;-webkit-transition: 0.3s all linear !important;-moz-transition: 0.3s all linear !important;-ms-transition: 0.3s all linear !important;transition: 0.3s all linear !important;}.bmc-button:hover, .bmc-button:active, .bmc-button:focus {-webkit-box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;text-decoration: none !important;box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;opacity: 0.85 !important;color:#ffffff !important;}</style><link href="https://fonts.googleapis.com/css?family=Cookie" rel="stylesheet">
  
  <div style="text-align: center;">
    <a class="bmc-button" target="_blank" href="https://www.buymeacoffee.com/BNJUu70"><img src="https://www.buymeacoffee.com/assets/img/BMC-btn-logo.svg" alt="Buy me a coffee"><span style="margin-left:5px">Buy me a coffee</span></a>
  </div>
  <script src="https://utteranc.es/client.js"
	  repo="kodingwarrior/kodingwarrior.github.io"
	  issue-term="title"
	  theme="github-light"
	  crossorigin="anonymous"
	  async>
  </script>
  

  
  
  <a class="u-url" href="/post/2019/04/13/Implementing-Lower-Bound-Using-Kotlin.html" hidden></a>
</article>

       </div>
     </main>

  </body>

  <footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">KODINGWARRIOR QUEST</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">KODINGWARRIOR QUEST</li><li><a class="u-email" href="mailto:kodingwarrior@mycodeis.sexy">kodingwarrior@mycodeis.sexy</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://www.facebook.com/kodingwarrior"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#facebook"></use></svg> <span class="username">kodingwarrior</span></a></li><li><a href="https://github.com/malkoG"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">malkoG</span></a></li><li><a href="https://www.twitter.com/codingwarrior_"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">codingwarrior_</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>SWAG 넘치는 개발자가 되기 위한 코딩대전사의 여정은 계속됩니다.</p>
      </div>
    </div>

  </div>

</footer>

</html>
